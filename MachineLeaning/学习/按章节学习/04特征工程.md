# 数值特征

```
特征工程是整个机器学习中非常重要的一部分，如何对数据进行特征提取对最终结果的影响非常大。在建模过程中，一般会优先考虑算法和参数，但是数据特征才决定了整体结果的上限，而算法和参数只决定了如何逼近这个上限。特征工程其实就是要从原始数据中找到最有价值的信息，并转换成计算机所能读懂的形式。本章结合数值数据与文本数据来分别阐述如何进行数值特征与文本特征的提取。
```


```python
import pandas as pd
import numpy as np

vg_df = pd.read_csv('vgsales.csv', encoding = "ISO-8859-1")
vg_df[['Name', 'Platform', 'Year', 'Genre', 'Publisher']].iloc[1:7]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Name</th>
      <th>Platform</th>
      <th>Year</th>
      <th>Genre</th>
      <th>Publisher</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>Super Mario Bros.</td>
      <td>NES</td>
      <td>1985.0</td>
      <td>Platform</td>
      <td>Nintendo</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Mario Kart Wii</td>
      <td>Wii</td>
      <td>2008.0</td>
      <td>Racing</td>
      <td>Nintendo</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Wii Sports Resort</td>
      <td>Wii</td>
      <td>2009.0</td>
      <td>Sports</td>
      <td>Nintendo</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Pokemon Red/Pokemon Blue</td>
      <td>GB</td>
      <td>1996.0</td>
      <td>Role-Playing</td>
      <td>Nintendo</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Tetris</td>
      <td>GB</td>
      <td>1989.0</td>
      <td>Puzzle</td>
      <td>Nintendo</td>
    </tr>
    <tr>
      <th>6</th>
      <td>New Super Mario Bros.</td>
      <td>DS</td>
      <td>2006.0</td>
      <td>Platform</td>
      <td>Nintendo</td>
    </tr>
  </tbody>
</table>
</div>



上述代码生成的数据中很多特征指标都是字符串，首先假设Genre列是最终的分类结果标签，但是计算机可不认识这些字符串，此时就需要将字符转换成数值。


```python
genres = np.unique(vg_df['Genre'])
genres
```




    array(['Action', 'Adventure', 'Fighting', 'Misc', 'Platform', 'Puzzle',
           'Racing', 'Role-Playing', 'Shooter', 'Simulation', 'Sports',
           'Strategy'], dtype=object)



读入数据后，最常见的情况就是很多特征并不是数值类型，而是用字符串来描述的，打印结果后发现，Genre列一共有12个不同的属性值，将其转换成数值即可，最简单的方法就是用数字进行映射：


```python
from sklearn.preprocessing import LabelEncoder

gle = LabelEncoder()
genre_labels = gle.fit_transform(vg_df['Genre'])
genre_mappings = {index: label for index, label in enumerate(gle.classes_)}
genre_mappings,genre_labels,gle.classes_
```




    ({0: 'Action',
      1: 'Adventure',
      2: 'Fighting',
      3: 'Misc',
      4: 'Platform',
      5: 'Puzzle',
      6: 'Racing',
      7: 'Role-Playing',
      8: 'Shooter',
      9: 'Simulation',
      10: 'Sports',
      11: 'Strategy'},
     array([10,  4,  6, ...,  6,  5,  4]),
     array(['Action', 'Adventure', 'Fighting', 'Misc', 'Platform', 'Puzzle',
            'Racing', 'Role-Playing', 'Shooter', 'Simulation', 'Sports',
            'Strategy'], dtype=object))



使用sklearn工具包中的**LabelEncoder()函数**可以快速地完成映射工作，默认是从数值0开始，fit\_transform()是实际执行的操作，自动对属性特征进行映射操作。变换完成之后，可以将新得到的结果加入原始DataFrame中对比一下：


```python
vg_df['GenreLabel'] = genre_labels
vg_df[['Name', 'Platform', 'Year', 'Genre', 'GenreLabel']].iloc[1:7]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Name</th>
      <th>Platform</th>
      <th>Year</th>
      <th>Genre</th>
      <th>GenreLabel</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>Super Mario Bros.</td>
      <td>NES</td>
      <td>1985.0</td>
      <td>Platform</td>
      <td>4</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Mario Kart Wii</td>
      <td>Wii</td>
      <td>2008.0</td>
      <td>Racing</td>
      <td>6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Wii Sports Resort</td>
      <td>Wii</td>
      <td>2009.0</td>
      <td>Sports</td>
      <td>10</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Pokemon Red/Pokemon Blue</td>
      <td>GB</td>
      <td>1996.0</td>
      <td>Role-Playing</td>
      <td>7</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Tetris</td>
      <td>GB</td>
      <td>1989.0</td>
      <td>Puzzle</td>
      <td>5</td>
    </tr>
    <tr>
      <th>6</th>
      <td>New Super Mario Bros.</td>
      <td>DS</td>
      <td>2006.0</td>
      <td>Platform</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




```python
poke_df = pd.read_csv('Pokemon.csv', encoding='utf-8')
poke_df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>#</th>
      <th>Name</th>
      <th>Type 1</th>
      <th>Type 2</th>
      <th>Total</th>
      <th>HP</th>
      <th>Attack</th>
      <th>Defense</th>
      <th>Sp. Atk</th>
      <th>Sp. Def</th>
      <th>Speed</th>
      <th>Generation</th>
      <th>Legendary</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Bulbasaur</td>
      <td>Grass</td>
      <td>Poison</td>
      <td>318</td>
      <td>45</td>
      <td>49</td>
      <td>49</td>
      <td>65</td>
      <td>65</td>
      <td>45</td>
      <td>1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Ivysaur</td>
      <td>Grass</td>
      <td>Poison</td>
      <td>405</td>
      <td>60</td>
      <td>62</td>
      <td>63</td>
      <td>80</td>
      <td>80</td>
      <td>60</td>
      <td>1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Venusaur</td>
      <td>Grass</td>
      <td>Poison</td>
      <td>525</td>
      <td>80</td>
      <td>82</td>
      <td>83</td>
      <td>100</td>
      <td>100</td>
      <td>80</td>
      <td>1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>VenusaurMega Venusaur</td>
      <td>Grass</td>
      <td>Poison</td>
      <td>625</td>
      <td>80</td>
      <td>100</td>
      <td>123</td>
      <td>122</td>
      <td>120</td>
      <td>80</td>
      <td>1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>Charmander</td>
      <td>Fire</td>
      <td>NaN</td>
      <td>309</td>
      <td>39</td>
      <td>52</td>
      <td>43</td>
      <td>60</td>
      <td>50</td>
      <td>65</td>
      <td>1</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>




```python
poke_df = poke_df.sample(random_state=1, frac=1).reset_index(drop=True)

np.unique(poke_df['Generation'])
```




    array([1, 2, 3, 4, 5, 6], dtype=int64)



　　这份数据集中同样有多个属性值需要映射，也可以自己动手写一个map函数，对应数值就从1开始吧：

```py
gen_ord_map = {'Gen 1': 1, 'Gen 2': 2, 'Gen 3': 3, 
               'Gen 4': 4, 'Gen 5': 5, 'Gen 6': 6}

poke_df['GenerationLabel'] = poke_df['Generation'].map(gen_ord_map)
poke_df[['Name', 'Generation', 'GenerationLabel']].iloc[4:10]
```
原数据已经处理好，可忽略


```python
from sklearn.preprocessing import OneHotEncoder, LabelEncoder

# 完成LabelEncoder
gen_le = LabelEncoder()
gen_labels = gen_le.fit_transform(poke_df['Generation'])
poke_df['Gen_Label'] = gen_labels

poke_df_sub = poke_df[['Name', 'Generation', 'Gen_Label', 'Legendary']]

# 完成OneHotEncoder
gen_ohe = OneHotEncoder()
gen_feature_arr = gen_ohe.fit_transform(poke_df[['Gen_Label']]).toarray()
gen_feature_labels = list(gen_le.classes_)

# 将转换好的特征组合到dataframe中
# gen_features = pd.DataFrame(gen_feature_arr, columns=gen_feature_labels)
# poke_df_ohe = pd.concat18 poke_df_ohe.head()
gen_features = pd.DataFrame(gen_feature_arr, columns=gen_feature_labels)
poke_df_ohe = pd.concat([poke_df_sub, gen_features], axis=1)
poke_df_ohe.head()

```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Name</th>
      <th>Generation</th>
      <th>Gen_Label</th>
      <th>Legendary</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>CharizardMega Charizard Y</td>
      <td>1</td>
      <td>0</td>
      <td>False</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Abomasnow</td>
      <td>4</td>
      <td>3</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Sentret</td>
      <td>2</td>
      <td>1</td>
      <td>False</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Litleo</td>
      <td>6</td>
      <td>5</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Octillery</td>
      <td>2</td>
      <td>1</td>
      <td>False</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>
</div>



这段代码涉及到使用`LabelEncoder`和`OneHotEncoder`对数据进行编码，并将编码后的特征合并到原始数据框中。下面是详细解释和数据变化过程：

1. **Label Encoding（标签编码）：**
   ```python
   gen_le = LabelEncoder()
   gen_labels = gen_le.fit_transform(poke_df['Generation'])
   poke_df['Gen_Label'] = gen_labels
   ```
   - 创建一个`LabelEncoder`对象`gen_le`。
   - 使用`fit_transform`方法将'Generation'列中的类别标签编码为数值，并将结果存储在新列'Gen_Label'中。

2. **Subset Data Frame（子数据框）：**
   ```python
   poke_df_sub = poke_df[['Name', 'Generation', 'Gen_Label', 'Legendary']]
   ```
   - 创建一个包含原始数据框中'Name', 'Generation', 'Gen_Label', 'Legendary'列的子数据框`poke_df_sub`。

3. **One-Hot Encoding（独热编码）：**
   ```python
   gen_ohe = OneHotEncoder()
   gen_feature_arr = gen_ohe.fit_transform(poke_df[['Gen_Label']]).toarray()
   gen_feature_labels = list(gen_le.classes_)
   ```
   - 创建一个`OneHotEncoder`对象`gen_ohe`。
   - 使用`fit_transform`方法将'Gen_Label'列进行独热编码，将结果转换为数组并存储在`gen_feature_arr`中。
   - 获取独热编码后的特征的列标签，即独热编码对应的类别标签。

4. **Concatenate DataFrames（合并数据框）：**
   ```python
   gen_features = pd.DataFrame(gen_feature_arr, columns=gen_feature_labels)
   poke_df_ohe = pd.concat([poke_df_sub, gen_features], axis=1)
   ```
   - 创建一个包含独热编码后的特征的数据框`gen_features`。
   - 使用`pd.concat`将原始数据框`poke_df_sub`和独热编码后的特征数据框`gen_features`沿着列的方向(axis=1)进行合并，得到新的数据框`poke_df_ohe`。

5. **显示前几行结果：**
   ```python
   poke_df_ohe.head()
   ```
   - 打印新的数据框的前几行，以便查看合并后的结果。

这段代码的目的是将'Generation'列进行标签编码，然后使用独热编码将标签编码后的特征添加到原始数据框中，形成一个包含独热编码后特征的新数据框。

## **LabelEncoder 和 OneHotEncoder 是什么**

-   在数据处理过程中，我们有时需要对不连续的数字或者文本进行数字化处理。
-   在使用 Python 进行数据处理时，用 encoder 来转化 dummy variable（虚拟数据）非常简便，encoder 可以将数据集中的文本转化成0或1的数值。
-   LabelEncoder 和 OneHotEncoder 是 scikit-learn 包中的两个功能，可以实现上述的转化过程。
-   sklearn.preprocessing.OneHotEncoder 的官方介绍：[LabelEncoder](https://link.zhihu.com/?target=http%3A//scikit-learn.org/dev/modules/generated/sklearn.preprocessing.LabelEncoder.html)
-   sklearn.preprocessing.OneHotEncoder 的官方介绍：[OneHotEnncoder](https://link.zhihu.com/?target=http%3A//scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html)

## **数据集中的类别数据**

在使用回归模型和机器学习模型时，所有的考察数据都是数值更容易得到好的结果。因为回归和机器学习都是基于数学函数方法的，所以当我们要分析的数据集中出现了类别数据(categorical data)，此时的数据是不理想的，因为我们不能用数学的方法处理它们。例如，在处理男和女两个性别数据时，我们用0和1将其代替，再进行分析。由于这种情况的出现，我们需要可以将文字数字化的现成方法。

## **LabelEncoder 和 OneHotEncoder 的例子**

下面是一个使用 Python sci-kit 包中 LableEncoder 和 OneHotEncoder 的具体例子：

![](https://pic4.zhimg.com/v2-2f846e154ca63689a6c8c03431ffb127_b.jpg)

![](https://pic4.zhimg.com/80/v2-2f846e154ca63689a6c8c03431ffb127_1440w.webp)

LableEncoder VS OneHotEncoder

-   首先，我们需要创建一个变量 **encoder\_x** 来进行编码工作。
-   程序执行过后，我们的类别数据就被转化成了数值0、1、2、3.
-   显然这种结果还不理想，因为计算机会对这些数值进行对比，例如2比1大，3比2也大，不利于我们进行数据分析。所以我们需要对这些数值进行再次的处理，得到一些虚拟数据。
-   接下来我们就需要借助 **OneHotEncoder** 来创造一些虚拟数据。
-   **OneHotEncoder** 可以把数据分成多个不同的列，每一列都用0或1来表示。
-   使用 OneHotEncoder 时，我们需要指明要处理的列。在这个例子中，我们想对第一列虚拟数据进行编码处理，所以我们设定 categorical\_features 中的 index＝0。

下面是具体代码：

```py
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
encoder_x=LabelEncoder()
x[:,0]=encoder_x.fit_transform(x[:,0])
onehotencoder = onehotencoder(categorical_features = [0])
x=onehotencoder.fit_transform(x).toarray()
x=x[:,1:]
```

## **远离虚拟数据陷阱**

-   如果数据集里面有一个以上的虚拟变量，而且这些虚拟变量之间又有联系，这样的数据集被数字化编码以后就容易掉入虚拟数据陷阱。
-   在上面的例子中，如果被分析变量不是 b, c 或 d，那么一定就是 a! 所以就会出现虚拟变量陷阱，这个陷阱的实质其实就是完全共线性。（矩阵不是满秩的）
-   接下来，我们需要去掉虚拟变量中的一列。也就是说，如果有 m 个定性变量，我们就引入 m-1 个虚拟变量。
-   代码的最后一行 x=x\[:,1:\] 作用是，从第1列开始复制数据中的所有行和所有列。
-   至此，第一列哑数据被去除了，虚拟数据陷阱就得以避免了。



1. **虚拟数据陷阱：**
   - 虚拟数据陷阱指的是在回归分析等统计模型中，由于使用了具有完全共线性的虚拟变量（哑变量），导致模型出现问题的情况。完全共线性意味着模型矩阵中的一列可以通过其他列的线性组合得到。在这种情况下，模型矩阵不是满秩的，可能导致模型无法正确拟合。

2. **避免虚拟数据陷阱的方法：**
   - 当引入虚拟变量时，为了避免完全共线性，需要确保任意一个虚拟变量不是其他虚拟变量的线性组合。
   - 在上述提到的例子中，如果有m个定性变量，应该引入m-1个虚拟变量。这是因为如果知道m-1个虚拟变量的取值，就可以推断出第m个变量的取值，造成完全共线性。

3. **去除虚拟变量中的一列：**
   - 为了避免虚拟数据陷阱，通常在处理虚拟变量时，需要去掉其中的一列。这样，每个虚拟变量的取值组合都是独立的，不会存在完全共线性的问题。
   - 例如，代码中的 `x = x[:, 1:]` 表示从第1列开始复制数据中的所有行和所有列，即保留除第一列外的所有虚拟变量。
   **虚拟变量陷阱（Dummy Variable Trap）**：指当原特征有m个类别时，如果将其转换成m个虚拟变量，就会导致变量间出现完全共线性的情况。

假设我们有一个特征“性别”，包含男性和女性两个类别，如果将此特征转换为2个虚拟变量，就是：男x<sub>1</sub>\=\[1,0\]，女x<sub>2</sub>\=\[0,1\]，意思就是：变量x<sub>1</sub>，当性别为男时，x<sub>1</sub>\=1，否则x<sub>1</sub>\=0；变量x<sub>2</sub>，当性别为女时，x<sub>2</sub>\=1，否则x<sub>2</sub>\=0。这样，目标y=w<sub>1</sub>x<sub>1</sub>+w<sub>2</sub>x<sub>2</sub>+b。因为x<sub>1</sub>+x<sub>2</sub>\=1，因此，变量x<sub>1</sub>和变量x<sub>2</sub>之间存在线性关系，同时使用这两个变量将会导致共线性问题，使得模型参数无法估计。

解决的办法是：把目标y变成y=w<sub>1</sub>(x<sub>1</sub>+x<sub>2</sub>)+(w<sub>2</sub>\-w<sub>1</sub>)x<sub>2</sub>+b=(w<sub>2</sub>\-w<sub>1</sub>)x<sub>2</sub>+w<sub>1</sub>+b，意思就是把其中一个变量作为基准（这里是把“男”作为基准），将其从目标方程式中删去，这样只通过一个变量x<sub>2</sub>就能推导出所有信息，x<sub>2</sub>\=1就表示性别为女，x<sub>2</sub>\=0则表示性别为男。

需要注意的是，针对二元定性变量到虚拟变量的转换，直接对类别进行数字编码（男：0，女：1）和将其转换为虚拟变量（男：\[0\]，女：\[1\]）看似一样，但这只是一个巧合而已，这两种方法有本质的区别。前者是直接将类别型变量转变成离散值进行表示，后者是减少一个变量（作为基准），只留取一个变量，在此基础上对另一个变量进行推论。一定要注意不要搞混了。

总结来说就是：**当原特征有m个类别时，我们需要将其转换成m-1个虚拟变量。**

还有一点需要注意的是，基准类别该如何选择？如果基准类别选择不合理，虚拟变量之间仍然会存在共线性的问题。这里直接给出结论：**选择占比最大的类别作为基准类别**。假设有a，b，c三个类别，如果基准类别a占比太少，那么即使把a去除，b和c之和也会接近于1。

总是可以从身边同学口中听到说到dummy化，dummy lr, 今天自己看了dummy variable的wiki，这里记下笔记总结：

dummy variable是用0或1表示某个类别是否出现  
为什么要dummy化  
若用数字1-12表示1-12月，那么就潜在表示了12月和1月差的很远，其实离的很近  
若用离散数字表示一地域，假如用数字1-23表示23个省，那么数字潜在的意思是，相邻的数字代表的省比较相似，差距的数字表示的省不相似，然而并没有这个意思。所以用单纯用离散的数字表示类别可能会影响后面回归或分类的精度  
另外要注意的是，dummy化不要冗余，比如有1-23个省，我们用22个0，1变量就可以表示，若22个变量都是0则表示第23个省。


## **LabelEncoder 和 OneHotEncoder 的区别**

-   LabelEncoder 将一列文本数据转化成数值。
-   例如，\[red, blue, red, yellow\] = \[0,2,0,1\]

![](https://pic4.zhimg.com/v2-d4285411aa3f82fe5970440b76a7badf_b.jpg)

![](https://pic4.zhimg.com/80/v2-d4285411aa3f82fe5970440b76a7badf_1440w.webp)

-   OneHotEncoder 将一列文本数据转化成一列或多列只有0和1的数据。
-   例如，\[red, blue, red, yellow\] = \[1,2,1,3\] 会被转化成3列用0和1表示的数据列，如下图：

![](https://pic2.zhimg.com/v2-9fa321df10122a6a2dbac2b31b1f5955_b.jpg)

![](https://pic2.zhimg.com/80/v2-9fa321df10122a6a2dbac2b31b1f5955_1440w.webp)

其实直接使用Pandas工具包更方便：


```python
gen_dummy_features = pd.get_dummies(poke_df['Generation'], drop_first=True)
pd.concat([poke_df[['Name', 'Generation']], gen_dummy_features], axis=1).iloc[4:10]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Name</th>
      <th>Generation</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>Octillery</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Helioptile</td>
      <td>6</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Dialga</td>
      <td>4</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>DeoxysDefense Forme</td>
      <td>3</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Rapidash</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>9</th>
      <td>Swanna</td>
      <td>5</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




```python
gen_onehot_features = pd.get_dummies(poke_df['Generation'],prefix = 'one-hot')
pd.concat([poke_df[['Name', 'Generation']], gen_onehot_features], axis=1).iloc[4:10]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Name</th>
      <th>Generation</th>
      <th>one-hot_1</th>
      <th>one-hot_2</th>
      <th>one-hot_3</th>
      <th>one-hot_4</th>
      <th>one-hot_5</th>
      <th>one-hot_6</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>Octillery</td>
      <td>2</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Helioptile</td>
      <td>6</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Dialga</td>
      <td>4</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>DeoxysDefense Forme</td>
      <td>3</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Rapidash</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>9</th>
      <td>Swanna</td>
      <td>5</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




```python
poke_df = pd.read_csv('Pokemon.csv', encoding='utf-8')
poke_df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>#</th>
      <th>Name</th>
      <th>Type 1</th>
      <th>Type 2</th>
      <th>Total</th>
      <th>HP</th>
      <th>Attack</th>
      <th>Defense</th>
      <th>Sp. Atk</th>
      <th>Sp. Def</th>
      <th>Speed</th>
      <th>Generation</th>
      <th>Legendary</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Bulbasaur</td>
      <td>Grass</td>
      <td>Poison</td>
      <td>318</td>
      <td>45</td>
      <td>49</td>
      <td>49</td>
      <td>65</td>
      <td>65</td>
      <td>45</td>
      <td>1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Ivysaur</td>
      <td>Grass</td>
      <td>Poison</td>
      <td>405</td>
      <td>60</td>
      <td>62</td>
      <td>63</td>
      <td>80</td>
      <td>80</td>
      <td>60</td>
      <td>1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Venusaur</td>
      <td>Grass</td>
      <td>Poison</td>
      <td>525</td>
      <td>80</td>
      <td>82</td>
      <td>83</td>
      <td>100</td>
      <td>100</td>
      <td>80</td>
      <td>1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>VenusaurMega Venusaur</td>
      <td>Grass</td>
      <td>Poison</td>
      <td>625</td>
      <td>80</td>
      <td>100</td>
      <td>123</td>
      <td>122</td>
      <td>120</td>
      <td>80</td>
      <td>1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>Charmander</td>
      <td>Fire</td>
      <td>NaN</td>
      <td>309</td>
      <td>39</td>
      <td>52</td>
      <td>43</td>
      <td>60</td>
      <td>50</td>
      <td>65</td>
      <td>1</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>



## 二值与多项式特征


```python
popsong_df = pd.read_csv('song_views.csv', encoding='utf-8')
popsong_df.head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>user_id</th>
      <th>song_id</th>
      <th>title</th>
      <th>listen_count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b6b799f34a204bd928ea014c243ddad6d0be4f8f</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b41ead730ac14f6b6717b9cf8859d5579f3f8d4d</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4c84359a164b161496d05282707cecbd50adbfc4</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>779b5908593756abb6ff7586177c966022668b06</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>dd88ea94f605a63d9fc37a214127e3f00e85e42d</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>68f0359a2f1cedb0d15c98d88017281db79f9bc6</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>116a4c95d63623a967edf2f3456c90ebbf964e6f</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>17</td>
    </tr>
    <tr>
      <th>7</th>
      <td>45544491ccfcdc0b0803c34f201a6287ed4e30f8</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>e701a24d9b6c59f5ac37ab28462ca82470e27cfb</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>68</td>
    </tr>
    <tr>
      <th>9</th>
      <td>edc8b7b1fd592a3b69c3d823a742e1a064abec95</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



　　数据中包括不同用户对歌曲的播放量，可以发现很多歌曲的播放量都是0，表示该用户还没有播放过此音乐，这个时候可以设置一个二值特征，以表示用户是否听过该歌曲：


```python
watched = np.array(popsong_df['listen_count']) #找到需要比较的特征
watched[watched >= 1] = 1
popsong_df['watched'] = watched
popsong_df.head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>user_id</th>
      <th>song_id</th>
      <th>title</th>
      <th>listen_count</th>
      <th>watched</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b6b799f34a204bd928ea014c243ddad6d0be4f8f</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b41ead730ac14f6b6717b9cf8859d5579f3f8d4d</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4c84359a164b161496d05282707cecbd50adbfc4</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>779b5908593756abb6ff7586177c966022668b06</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>dd88ea94f605a63d9fc37a214127e3f00e85e42d</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>68f0359a2f1cedb0d15c98d88017281db79f9bc6</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>116a4c95d63623a967edf2f3456c90ebbf964e6f</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>17</td>
      <td>1</td>
    </tr>
    <tr>
      <th>7</th>
      <td>45544491ccfcdc0b0803c34f201a6287ed4e30f8</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>e701a24d9b6c59f5ac37ab28462ca82470e27cfb</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>68</td>
      <td>1</td>
    </tr>
    <tr>
      <th>9</th>
      <td>edc8b7b1fd592a3b69c3d823a742e1a064abec95</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




```python
from sklearn.preprocessing import Binarizer

bn = Binarizer(threshold=0.9)
pd_watched = bn.transform([popsong_df['listen_count']])[0]
popsong_df['pd_watched'] = pd_watched
popsong_df.head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>user_id</th>
      <th>song_id</th>
      <th>title</th>
      <th>listen_count</th>
      <th>watched</th>
      <th>pd_watched</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b6b799f34a204bd928ea014c243ddad6d0be4f8f</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b41ead730ac14f6b6717b9cf8859d5579f3f8d4d</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4c84359a164b161496d05282707cecbd50adbfc4</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>779b5908593756abb6ff7586177c966022668b06</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>dd88ea94f605a63d9fc37a214127e3f00e85e42d</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>68f0359a2f1cedb0d15c98d88017281db79f9bc6</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>116a4c95d63623a967edf2f3456c90ebbf964e6f</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>17</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>7</th>
      <td>45544491ccfcdc0b0803c34f201a6287ed4e30f8</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>e701a24d9b6c59f5ac37ab28462ca82470e27cfb</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>68</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>9</th>
      <td>edc8b7b1fd592a3b69c3d823a742e1a064abec95</td>
      <td>SOBONKR12A58A7A7E0</td>
      <td>You're The One</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



https://scikit-learn.org.cn/view/721.html
```py
class sklearn.preprocessing.Binarizer(*, threshold=0.0, copy=True)

```

[\[源码\]](https://github.com/scikit-learn/scikit-learn/blob/fd237278e/sklearn/preprocessing/_data.py#L1891)

根据阈值对数据进行二值化（将要素值设置为0或1）

大于阈值的值映射为1，而小于或等于阈值的值映射为0。默认阈值为0时，仅正值映射为1。

二值化是对文本计数数据的常见操作，分析人员可以决定仅考虑某个功能的存在或不存在，而不考虑例如量化的出现次数。

对于考虑了布尔型随机变量的估计量（例如，使用贝叶斯设置中的伯努利分布建模的估计量），它也可以用作预处理器。

在[用户指南](http://scikit-learn.org.cn/view/123.html#6.3.5%20%E7%A6%BB%E6%95%A3%E5%8C%96)中阅读更多内容

| 参数 | 说明 |
| --- | --- |
| **threshold** | **float, optional (0.0 by default)**  
小于或等于此值的特征值将替换为0，在其之上被1替换。对于稀疏矩阵的操作，阈值不得小于0。 |
| **copy** | **boolean, optional, default True**  
设置为False将执行就地二进制化并避免复制（如果输入已经是numpy数组或scipy.sparse CSR矩阵）。 |

> **另见：**

[`binarize`](https://scikit-learn.org.cn/view/758.html)

没有估算器API的等效函数。

**注释**

如果输入是稀疏矩阵，则只有非零值会由Binarizer类更新。该估计器是无状态的（除了构造函数参数之外），fit方法什么也不做，但是在管道(pipeline)中使用时很有用。

**示例：**

\>>>

```py
>>> from sklearn.preprocessing import Binarizer
>>> X = [[ 1., -1.,  2.],
...      [ 2.,  0.,  0.],
...      [ 0.,  1., -1.]]
>>> transformer = Binarizer().fit(X)  # fit does nothing.
>>> transformer
Binarizer()
>>> transformer.transform(X)
array([[1., 0., 1.],
       [1., 0., 0.],
       [0., 1., 0.]])
```

**方法**

| 方法 | 说明 |
| --- | --- |
| `fit`(self, X\[, y\]) | 不执行任何操作，并使估算器保持不变 |
| `fit_transform`(self, X\[, y\]) | 拟合数据，然后对其进行转换。 |
| `get_params`(self\[, deep\]) | 获取此估计量的参数。 |
| `set_params`(self, \*\*params) | 设置此估算器的参数。 |
| `transform`(self, X\[, copy\]) | 对X的每个元素进行二值化 |

```py
__init__(self, *, threshold=0.0, copy=True)

```


不执行任何操作并返回不变的估算器。该方法仅用于实现常规API，因此可以在管道中使用。

| 参数 | 说明 |
| --- | --- |
| **X** | **array-like** |

```
fit_transform(self, X, y=None, *fit_params)

```

[\[源码\]](https://github.com/scikit-learn/scikit-learn/blob/fd237278e/sklearn/base.py#L663)

拟合数据，然后对其进行转换。

使用可选参数fit\_params将转换器拟合到X和y，并返回X的转换值。

| 参数 | 说明 |
| --- | --- |
| **X** | **{array-like, sparse matrix, dataframe} of shape (n\_sample, n\_features)** |
| **y** | **ndarray of shape (n\_samples, ), default = None**  
目标值 |
| **\*\*fit\_params** | **dict**  
附加拟合参数 |

| 返回值 | 说明 |
| --- | --- |
| **X\_new** | **ndarray array of shape (n\_samples, n\_features\_new)**  
转化后的数组 |

```
get_params(self, deep=True)

```

[源码](https://github.com/scikit-learn/scikit-learn/blob/fd237278e/sklearn/base.py#L189)

获取当前估计量的参数

| 参数 | 说明 |
| --- | --- |
| **deep** | **bool, default = True**  
如果为真，则将返回此估计器和其所包含子对象的参数 |

| 返回值 | 说明 |
| --- | --- |
| **params** | **mapping of string to any**  
参数名被映射至他们的值 |

```
predict(self, **params)

```

[源码](https://github.com/scikit-learn/scikit-learn/blob/fd237278e/sklearn/base.py#L221)

设置当前估算器的参数。

该方法适用于简单的估计器以及嵌套对象（例如管道）。后者的参数形式为<component>\_\_<parameter>这样就可以更新嵌套对象的每个组件。

| 参数 | 说明 |
| --- | --- |
| **\*\*params** | **dict**  
估计量参数 |

| 返回值 | 说明 |
| --- | --- |
| **self** | **object**  
估计器实例 |

```
transform(self, X，copy=None)

```

[\[源码\]](https://github.com/scikit-learn/scikit-learn/blob/fd237278e/sklearn/preprocessing/_data.py#L1963)

对X的每个元素进行二值化

| 参数 | 说明 |
| --- | --- |
| **X** | **{array-like, sparse matrix}, shape \[n\_samples, n\_features\]**  
要逐元素二值化的数据。稀疏矩阵应采用CSR格式，以避免不必要的复制。 |
| **copy** | **bool**  
是否复制输入X。 |

　特征的变换方法还有很多，还可以对其进行各种组合。接下来登场的就是多项式特征，例如有a、b两个特征，那么它的2次多项式为（1,a,b,a<sup>2</sup>,ab,b<sup>2</sup>），下面通过sklearn工具包完成变换操作：


```python
poke_df = pd.read_csv('Pokemon.csv', encoding='utf-8')
atk_def = poke_df[['Attack', 'Defense']]
atk_def.head()

```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Attack</th>
      <th>Defense</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>49</td>
      <td>49</td>
    </tr>
    <tr>
      <th>1</th>
      <td>62</td>
      <td>63</td>
    </tr>
    <tr>
      <th>2</th>
      <td>82</td>
      <td>83</td>
    </tr>
    <tr>
      <th>3</th>
      <td>100</td>
      <td>123</td>
    </tr>
    <tr>
      <th>4</th>
      <td>52</td>
      <td>43</td>
    </tr>
  </tbody>
</table>
</div>




```python

from sklearn.preprocessing import PolynomialFeatures

pf = PolynomialFeatures(degree=2, interaction_only=False, include_bias=False)
res = pf.fit_transform(atk_def)
res[:5]
```




    array([[   49.,    49.,  2401.,  2401.,  2401.],
           [   62.,    63.,  3844.,  3906.,  3969.],
           [   82.,    83.,  6724.,  6806.,  6889.],
           [  100.,   123., 10000., 12300., 15129.],
           [   52.,    43.,  2704.,  2236.,  1849.]])



　PolynomialFeatures()函数涉及以下3个参数。

-   degree：控制多项式的度，如果设置的数值越大，特征结果也会越多。
-   interaction\_only：默认为False。如果指定为True，那么不会有特征自己和自己结合的项，例如上面的二次项中没有a<sup>2</sup>和b<sup>2</sup>。
-   include\_bias：默认为True。如果为True的话，那么会新增1列。

　　为了更清晰地展示，可以加上操作的列名：


```python
intr_features = pd.DataFrame(res, columns=['Attack', 'Defense', 'Attack^2', 'Attack x Defense', 'Defense^2'])
intr_features.head(5)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Attack</th>
      <th>Defense</th>
      <th>Attack^2</th>
      <th>Attack x Defense</th>
      <th>Defense^2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>49.0</td>
      <td>49.0</td>
      <td>2401.0</td>
      <td>2401.0</td>
      <td>2401.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>62.0</td>
      <td>63.0</td>
      <td>3844.0</td>
      <td>3906.0</td>
      <td>3969.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>82.0</td>
      <td>83.0</td>
      <td>6724.0</td>
      <td>6806.0</td>
      <td>6889.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>100.0</td>
      <td>123.0</td>
      <td>10000.0</td>
      <td>12300.0</td>
      <td>15129.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>52.0</td>
      <td>43.0</td>
      <td>2704.0</td>
      <td>2236.0</td>
      <td>1849.0</td>
    </tr>
  </tbody>
</table>
</div>



## 连续值离散化


```python
fcc_survey_df = pd.read_csv('fcc_2016_coder_survey_subset.csv', encoding='utf-8')
fcc_survey_df[['ID.x', 'EmploymentField', 'Age', 'Income']].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID.x</th>
      <th>EmploymentField</th>
      <th>Age</th>
      <th>Income</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>cef35615d61b202f1dc794ef2746df14</td>
      <td>office and administrative support</td>
      <td>28.0</td>
      <td>32000.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>323e5a113644d18185c743c241407754</td>
      <td>food and beverage</td>
      <td>22.0</td>
      <td>15000.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b29a1027e5cd062e654a63764157461d</td>
      <td>finance</td>
      <td>19.0</td>
      <td>48000.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>04a11e4bcb573a1261eb0d9948d32637</td>
      <td>arts, entertainment, sports, or media</td>
      <td>26.0</td>
      <td>43000.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>9368291c93d5d5f5c8cdb1a575e18bec</td>
      <td>education</td>
      <td>20.0</td>
      <td>6000.0</td>
    </tr>
  </tbody>
</table>
</div>



　　上述代码读取了一份带有年龄信息的数据集，接下来要对年龄特征进行离散化操作，也就是划分成一个个区间，实际操作之前，可以观察其分布情况：


```python
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
import scipy.stats as spstats

%matplotlib inline
mpl.style.reload_library()
mpl.style.use('classic')
mpl.rcParams['figure.facecolor'] = (1, 1, 1, 0)
mpl.rcParams['figure.figsize'] = [6.0, 4.0]
mpl.rcParams['figure.dpi'] = 100

fig, ax = plt.subplots()
fcc_survey_df['Age'].hist(color='#A9C5D3')
ax.set_title('Developer Age Histogram', fontsize=12)
ax.set_xlabel('Age', fontsize=12)
ax.set_ylabel('Frequency', fontsize=12)
'''
上述代码是使用Python中的matplotlib库进行数据可视化的示例。下面是对其中涉及到的用法的解释：

1. `%matplotlib inline`: 这是一个Jupyter Notebook的魔术命令，用于在Notebook中嵌入绘图，并且不需要使用`plt.show()`来显示图形。

2. `mpl.style.reload_library()`: 重新加载matplotlib的样式库。

3. `mpl.style.use('classic')`: 使用经典的matplotlib样式，这会影响图形的外观，包括颜色和线条样式。

4. `mpl.rcParams['figure.facecolor'] = (1, 1, 1, 0)`: 设置图形的背景颜色为透明。

5. `mpl.rcParams['figure.figsize'] = [6.0, 4.0]`: 设置图形的尺寸为宽6.0英寸，高4.0英寸。

6. `mpl.rcParams['figure.dpi'] = 100`: 设置图形的分辨率为100 dots per inch (DPI)。

7. `fig, ax = plt.subplots()`: 创建一个包含一个坐标轴(ax)的图形(fig)。

8. `fcc_survey_df['Age'].hist(color='#A9C5D3')`: 绘制fcc_survey_df数据框中'Age'列的直方图，使用颜色'#A9C5D3'。

9. `ax.set_title('Developer Age Histogram', fontsize=12)`: 设置图形的标题为'Developer Age Histogram'，字体大小为12。

10. `ax.set_xlabel('Age', fontsize=12)`: 设置x轴标签为'Age'，字体大小为12。

11. `ax.set_ylabel('Frequency', fontsize=12)`: 设置y轴标签为'Frequency'，字体大小为12。
'''
```




    Text(0, 0.5, 'Frequency')




    
![png](%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B_files/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B_33_1.png)
    


　　上述输出结果显示，年龄特征的取值范围在10～90之间。所谓离散化，就是将一段区间上的数据映射到一个组中，例如按照年龄大小可分成儿童、青年、中年、老年等。简单起见，这里直接按照相同间隔进行划分：


```python
fcc_survey_df['Age_bin_round'] = np.array(np.floor(np.array(fcc_survey_df['Age']) / 10.))
fcc_survey_df[['ID.x', 'Age', 'Age_bin_round']].iloc[1071:1076]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID.x</th>
      <th>Age</th>
      <th>Age_bin_round</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1071</th>
      <td>6a02aa4618c99fdb3e24de522a099431</td>
      <td>17.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1072</th>
      <td>f0e5e47278c5f248fe861c5f7214c07a</td>
      <td>38.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>1073</th>
      <td>6e14f6d0779b7e424fa3fdd9e4bd3bf9</td>
      <td>21.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>1074</th>
      <td>c2654c07dc929cdf3dad4d1aec4ffbb3</td>
      <td>53.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>1075</th>
      <td>f07449fc9339b2e57703ec7886232523</td>
      <td>35.0</td>
      <td>3.0</td>
    </tr>
  </tbody>
</table>
</div>



　　上述代码中，np.floor表示向下取整，例如，对3.3取整后，得到的就是3。这样就完成了连续值的离散化，所有数值都划分到对应的区间上。

　　还可以利用分位数进行分箱操作，换一个特征试试，先来看看收入的情况：


```python
#fcc_survey_df[['ID.x', 'Age', 'Income']].iloc[4:9]
fig, ax = plt.subplots()
fcc_survey_df['Income'].hist(bins=30, color='#A9C5D3')
ax.set_title('Developer Income Histogram', fontsize=12)
ax.set_xlabel('Developer Income', fontsize=12)
ax.set_ylabel('Frequency', fontsize=12)
```




    Text(0, 0.5, 'Frequency')




    
![png](%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B_files/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B_37_1.png)
    


 　　分位数就是按照比例来划分，也可以自定义合适的比例：




```python
quantile_list = [0, .25, .5, .75, 1.]
quantiles = fcc_survey_df['Income'].quantile(quantile_list)
quantiles
```




    0.00      6000.0
    0.25     20000.0
    0.50     37000.0
    0.75     60000.0
    1.00    200000.0
    Name: Income, dtype: float64




```python
fig, ax = plt.subplots()
fcc_survey_df['Income'].hist(bins=30, color='#A9C5D3')

for quantile in quantiles:
    qvl = plt.axvline(quantile, color='r')
ax.legend([qvl], ['Quantiles'], fontsize=10)

ax.set_title('Developer Income Histogram with Quantiles', fontsize=12)
ax.set_xlabel('Developer Income', fontsize=12)
ax.set_ylabel('Frequency', fontsize=12)
```




    Text(0, 0.5, 'Frequency')




    
![png](%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B_files/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B_40_1.png)
    


　　Quantile函数就是按照选择的比例得到对应的切分值，再应用到数据中进行离散化操作即可：




```python
quantile_labels = ['0-25Q', '25-50Q', '50-75Q', '75-100Q']
fcc_survey_df['Income_quantile_range'] = pd.qcut(fcc_survey_df['Income'],
                                                 q=quantile_list)
fcc_survey_df['Income_quantile_label'] = pd.qcut(fcc_survey_df['Income'],
                                                 q=quantile_list, labels=quantile_labels)
fcc_survey_df[['ID.x', 'Age', 'Income',
               'Income_quantile_range', 'Income_quantile_label']].iloc[4:9]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID.x</th>
      <th>Age</th>
      <th>Income</th>
      <th>Income_quantile_range</th>
      <th>Income_quantile_label</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>9368291c93d5d5f5c8cdb1a575e18bec</td>
      <td>20.0</td>
      <td>6000.0</td>
      <td>(5999.999, 20000.0]</td>
      <td>0-25Q</td>
    </tr>
    <tr>
      <th>5</th>
      <td>dd0e77eab9270e4b67c19b0d6bbf621b</td>
      <td>34.0</td>
      <td>40000.0</td>
      <td>(37000.0, 60000.0]</td>
      <td>50-75Q</td>
    </tr>
    <tr>
      <th>6</th>
      <td>7599c0aa0419b59fd11ffede98a3665d</td>
      <td>23.0</td>
      <td>32000.0</td>
      <td>(20000.0, 37000.0]</td>
      <td>25-50Q</td>
    </tr>
    <tr>
      <th>7</th>
      <td>6dff182db452487f07a47596f314bddc</td>
      <td>35.0</td>
      <td>40000.0</td>
      <td>(37000.0, 60000.0]</td>
      <td>50-75Q</td>
    </tr>
    <tr>
      <th>8</th>
      <td>9dc233f8ed1c6eb2432672ab4bb39249</td>
      <td>33.0</td>
      <td>80000.0</td>
      <td>(60000.0, 200000.0]</td>
      <td>75-100Q</td>
    </tr>
  </tbody>
</table>
</div>



 　　此时所有数据都完成了分箱操作，拿到实际数据后如何指定比例就得看具体问题，并没有固定不变的规则，根据实际业务来判断才是最科学的。

## 对数与时间变换

 　　拿到某列数据特征后，其分布可能是各种各样的情况，但是，很多机器学习算法希望预测的结果值能够呈现高斯分布，这就需要再对其进行变换，最直接的就是对数变换：


```python
fcc_survey_df['Income_log'] = np.log((1+ fcc_survey_df['Income']))
fcc_survey_df[['ID.x', 'Age', 'Income', 'Income_log']].iloc[4:9]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID.x</th>
      <th>Age</th>
      <th>Income</th>
      <th>Income_log</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>9368291c93d5d5f5c8cdb1a575e18bec</td>
      <td>20.0</td>
      <td>6000.0</td>
      <td>8.699681</td>
    </tr>
    <tr>
      <th>5</th>
      <td>dd0e77eab9270e4b67c19b0d6bbf621b</td>
      <td>34.0</td>
      <td>40000.0</td>
      <td>10.596660</td>
    </tr>
    <tr>
      <th>6</th>
      <td>7599c0aa0419b59fd11ffede98a3665d</td>
      <td>23.0</td>
      <td>32000.0</td>
      <td>10.373522</td>
    </tr>
    <tr>
      <th>7</th>
      <td>6dff182db452487f07a47596f314bddc</td>
      <td>35.0</td>
      <td>40000.0</td>
      <td>10.596660</td>
    </tr>
    <tr>
      <th>8</th>
      <td>9dc233f8ed1c6eb2432672ab4bb39249</td>
      <td>33.0</td>
      <td>80000.0</td>
      <td>11.289794</td>
    </tr>
  </tbody>
</table>
</div>




```python
income_log_mean = np.round(np.mean(fcc_survey_df['Income_log']), 2)

fig, ax = plt.subplots()
fcc_survey_df['Income_log'].hist(bins=30, color='#A9C5D3')
plt.axvline(income_log_mean, color='r')
ax.set_title('Developer Income Histogram after Log Transform', fontsize=12)
ax.set_xlabel('Developer Income (log scale)', fontsize=12)
ax.set_ylabel('Frequency', fontsize=12)
ax.text(11.5, 450, r'$\mu$='+str(income_log_mean), fontsize=10)
```




    Text(11.5, 450, '$\\mu$=10.43')




    
![png](%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B_files/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B_46_1.png)
    


　　经过对数变换之后，特征分布更接近高斯分布，虽然还不够完美，但还是有些进步的，感兴趣的读者还可以进一步了解cox-box变换，目的都是相同的，只是在公式上有点区别。

　　时间相关数据也是可以提取出很多特征，例如年、月、日、小时等，甚至上旬、中旬、下旬、工作时间、下班时间等都可以当作算法的输入特征。


```python
import datetime
import numpy as np
import pandas as pd
from dateutil.parser import parse
import pytz

import numpy as np
import pandas as pd

time_stamps = ['2015-03-08 10:30:00.360000+00:00', '2017-07-13 15:45:05.755000-07:00',
               '2012-01-20 22:30:00.254000+05:30', '2016-12-25 00:30:00.000000+10:00']
df = pd.DataFrame(time_stamps, columns=['Time'])
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015-03-08 10:30:00.360000+00:00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2017-07-13 15:45:05.755000-07:00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2012-01-20 22:30:00.254000+05:30</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2016-12-25 00:30:00.000000+10:00</td>
    </tr>
  </tbody>
</table>
</div>



　　接下来就要得到各种细致的时间特征，如果用的是标准格式的数据，也可以直接调用其属性，更方便一些：


```python
ts_objs = np.array([pd.Timestamp(item) for item in np.array(df.Time)])
df['TS_obj'] = ts_objs
ts_objs
```




    array([Timestamp('2015-03-08 10:30:00.360000+0000', tz='UTC'),
           Timestamp('2017-07-13 15:45:05.755000-0700', tz='pytz.FixedOffset(-420)'),
           Timestamp('2012-01-20 22:30:00.254000+0530', tz='pytz.FixedOffset(330)'),
           Timestamp('2016-12-25 00:30:00+1000', tz='pytz.FixedOffset(600)')],
          dtype=object)




```python
df['Year'] = df['TS_obj'].apply(lambda d: d.year)
df['Month'] = df['TS_obj'].apply(lambda d: d.month)
df['Day'] = df['TS_obj'].apply(lambda d: d.day)
df['DayOfWeek'] = df['TS_obj'].apply(lambda d: d.dayofweek)
# df['DayName'] = df['TS_obj'].apply(lambda d: d.weekday_name)#
# AttributeError: 'Timestamp' object has no attribute 'weekday_name'
df['DayOfYear'] = df['TS_obj'].apply(lambda d: d.dayofyear)
df['WeekOfYear'] = df['TS_obj'].apply(lambda d: d.weekofyear)
df['Quarter'] = df['TS_obj'].apply(lambda d: d.quarter)
df['Hour'] = df['TS_obj'].apply(lambda d: d.hour)

# df[['Time', 'Year', 'Month', 'Day', 'Quarter',
#     'DayOfWeek', 'DayName', 'DayOfYear', 'WeekOfYear']]
df[['Time', 'Year', 'Month', 'Day', 'Quarter',
    'DayOfWeek',  'DayOfYear', 'WeekOfYear']]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Time</th>
      <th>Year</th>
      <th>Month</th>
      <th>Day</th>
      <th>Quarter</th>
      <th>DayOfWeek</th>
      <th>DayOfYear</th>
      <th>WeekOfYear</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015-03-08 10:30:00.360000+00:00</td>
      <td>2015</td>
      <td>3</td>
      <td>8</td>
      <td>1</td>
      <td>6</td>
      <td>67</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2017-07-13 15:45:05.755000-07:00</td>
      <td>2017</td>
      <td>7</td>
      <td>13</td>
      <td>3</td>
      <td>3</td>
      <td>194</td>
      <td>28</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2012-01-20 22:30:00.254000+05:30</td>
      <td>2012</td>
      <td>1</td>
      <td>20</td>
      <td>1</td>
      <td>4</td>
      <td>20</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2016-12-25 00:30:00.000000+10:00</td>
      <td>2016</td>
      <td>12</td>
      <td>25</td>
      <td>4</td>
      <td>6</td>
      <td>360</td>
      <td>51</td>
    </tr>
  </tbody>
</table>
</div>




```python
hour_bins = [-1, 5, 11, 16, 21, 23]
bin_names = ['Late Night', 'Morning', 'Afternoon', 'Evening', 'Night']
df['TimeOfDayBin'] = pd.cut(df['Hour'], 
                            bins=hour_bins, labels=bin_names)
df[['Time', 'Hour', 'TimeOfDayBin']]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Time</th>
      <th>Hour</th>
      <th>TimeOfDayBin</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015-03-08 10:30:00.360000+00:00</td>
      <td>10</td>
      <td>Morning</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2017-07-13 15:45:05.755000-07:00</td>
      <td>15</td>
      <td>Afternoon</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2012-01-20 22:30:00.254000+05:30</td>
      <td>22</td>
      <td>Night</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2016-12-25 00:30:00.000000+10:00</td>
      <td>0</td>
      <td>Late Night</td>
    </tr>
  </tbody>
</table>
</div>



https://www.cnblogs.com/downmoon/p/12685420.html
其余不是主攻方向，tobe continue
